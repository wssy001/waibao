---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by alexpetertyler.
--- DateTime: 2022/3/4 11:45
---
-- batchInsertGoodsScript GoodsCacheService
--private Long id;
--private Long goodsId;
--private Long retailerId;
--private BigDecimal price;
--private BigDecimal seckillPrice;
--private Integer storage;
--private Integer purchaseLimit;
--private Date seckillStartTime;
--private Date seckillEndTime;
local key = KEYS[1]
local seckillGoodsList = {}
local seckillGoods
local goodsId
for _, value in ipairs(ARGV) do
    seckillGoods = cjson.decode(value)
    goodsId = seckillGoods['goodsId']
    if next(redis.call('HKEYS', key .. goodsId)) then
        table.insert(seckillGoodsList, seckillGoods)
    else
        redis.call('HSET', key .. goodsId, 'id', seckillGoods['id'], 'goodsId', goodsId, 'retailerId',
                seckillGoods['retailerId'], 'price', seckillGoods['price'], 'seckillPrice',
                seckillGoods['seckillPrice'], 'storage', seckillGoods['storage'], 'purchaseLimit',
                seckillGoods['purchaseLimit'], 'seckillEndTime', seckillGoods['seckillEndTime'],
                '@type', 'com.waibao.seckill.entity.SeckillGoods')
    end
end

if not next(seckillGoodsList) then
    return nil
else
    return cjson.encode(seckillGoodsList)
end


-- insertGoodsScript GoodsCacheService
local key = KEYS[1]
local goodsId = seckillGoods['goodsId']
local seckillGoods = cjson.decode(ARGV[1])
redis.call('HSET', key .. goodsId, 'id', seckillGoods['id'], 'goodsId', goodsId, 'retailerId',
        seckillGoods['retailerId'], 'price', seckillGoods['price'], 'seckillPrice',
        seckillGoods['seckillPrice'], 'storage', seckillGoods['storage'], 'purchaseLimit',
        seckillGoods['purchaseLimit'], 'seckillEndTime', seckillGoods['seckillEndTime'],
        '@type', 'com.waibao.seckill.entity.SeckillGoods')


-- canalSyncGoodsScript GoodsCacheService
local key = KEYS[1]
local redisCommand
local seckillGoods
local goodsId
for _, value in ipairs(ARGV) do
    redisCommand = cjson.decode(value)
    seckillGoods = redisCommand['value']
    goodsId = seckillGoods['goodsId']
    key = '"' .. string.gsub(key, '"', '') .. seckillGoods['goodsId'] .. '"'
    if redisCommand['command'] == 'SET' then
        redis.call('HSET', key, 'id', seckillGoods['id'], 'goodsId', goodsId, 'retailerId',
                seckillGoods['retailerId'], 'price', seckillGoods['price'], 'seckillPrice',
                seckillGoods['seckillPrice'], 'storage', seckillGoods['storage'], 'purchaseLimit',
                seckillGoods['purchaseLimit'], 'seckillEndTime', seckillGoods['seckillEndTime'],
                '@type', 'com.waibao.seckill.entity.SeckillGoods')
    else
        redis.call('DEL', key)
    end
end


-- getGoodsScript GoodsCacheService
local key = KEYS[1]
local seckillGoods = {}
local goodsId = ARGV[1]
local seckillGoodsKeys = redis.call('HVALS', key .. goodsId)
for _, value in ipairs(seckillGoodsKeys) do
    seckillGoods[value] = redis.call('HGET', key .. goodsId, value)
end

return cjson.encode(seckillGoods)


-- batchRollBackStorage GoodsCacheService
--private String orderId;
--private Long goodsId;
--private Long userId;
--private Long retailerId;
--private BigDecimal goodsPrice;
--private Integer count;
--private BigDecimal orderPrice;
--private Date purchaseTime;
--private Boolean paid = false;
--private String status;
local key = KEYS[1]
local orderVO
local orderVOList = {}
local goodsId
for _, value in ipairs(ARGV) do
    orderVO = cjson.decode(value)
    goodsId = orderVO['goodsId']
    if next(redis.call('HKEYS', key .. goodsId)) then
        orderVO['status'] = '库存回滚失败'
        table.insert(orderVOList, orderVO)
    else
        redis.call('HINCRBY', key .. goodsId, 'storage', orderVO['count'])
        orderVO['status'] = '库存回滚成功'
    end
end

if not next(orderVOList) then
    return nil
else
    return cjson.encode(orderVOList)
end


-- decreaseStorage GoodsCacheService
local key = KEYS[1]
local goodsId = ARGV[1]
local count = ARGV[2]
if tonumber(redis.call('HEGT', key .. goodsId, 'purchaseLimit')) < count then
    return false
end
if tonumber(redis.call('HINCRBY', key .. goodsId, 'storage', -count)) < 0 then
    redis.call('HINCRBY', key .. goodsId, 'storage', count)
    return false
else
    return true
end


-- batchInsertGoodsRetailerScript GoodsRetailerCacheService
local key = KEYS[1]
local seckillGoodsList = {}
local retailerId
local seckillGoods
local goodsId
for _, value in ipairs(ARGV) do
    seckillGoods = cjson.decode(value)
    goodsId = seckillGoods['goodsId']
    retailerId = seckillGoods['retailerId']
    if next(redis.call('HKEYS', key .. retailerId .. '-' .. goodsId)) then
        table.insert(seckillGoodsList, seckillGoods)
    else
        redis.call('HSET', key .. retailerId .. '-' .. goodsId, 'id', seckillGoods['id'], 'goodsId', goodsId, 'retailerId',
                seckillGoods['retailerId'], 'price', seckillGoods['price'], 'seckillPrice',
                seckillGoods['seckillPrice'], 'storage', seckillGoods['storage'], 'purchaseLimit',
                seckillGoods['purchaseLimit'], 'seckillEndTime', seckillGoods['seckillEndTime'],
                '@type', 'com.waibao.seckill.entity.SeckillGoods')
    end
end

if not next(seckillGoodsList) then
    return nil
else
    return cjson.encode(seckillGoodsList)
end


-- insertGoodsRetailerScript GoodsRetailerCacheService
local key = KEYS[1]
local seckillGoods = cjson.decode(ARGV[1])
redis.call('HSET', key .. seckillGoods['retailerId'] .. '-' .. seckillGoods['goodsId'], 'id', seckillGoods['id'], 'goodsId', goodsId, 'retailerId',
        seckillGoods['retailerId'], 'price', seckillGoods['price'], 'seckillPrice',
        seckillGoods['seckillPrice'], 'storage', seckillGoods['storage'], 'purchaseLimit',
        seckillGoods['purchaseLimit'], 'seckillEndTime', seckillGoods['seckillEndTime'],
        '@type', 'com.waibao.seckill.entity.SeckillGoods')


-- canalSyncGoodsRetailerScript GoodsRetailerCacheService
local key = KEYS[1]
local redisCommand
local seckillGoods
local goodsId
for _, value in ipairs(ARGV) do
    redisCommand = cjson.decode(value)
    seckillGoods = redisCommand['value']
    goodsId = seckillGoods['goodsId']
    key = '"' .. string.gsub(key, '"', '')
    if redisCommand['command'] == 'SET' then
        redis.call('HSET', key .. seckillGoods['retailerId'] .. goodsId, 'id', seckillGoods['id'], 'goodsId', goodsId,
                'retailerId', seckillGoods['retailerId'], 'price', seckillGoods['price'], 'seckillPrice',
                seckillGoods['seckillPrice'], 'storage', seckillGoods['storage'], 'purchaseLimit',
                seckillGoods['purchaseLimit'], 'seckillEndTime', seckillGoods['seckillEndTime'],
                '@type', 'com.waibao.seckill.entity.SeckillGoods')
    else
        redis.call('DEL', key)
    end
end


-- getGoodsRetailerScript GoodsRetailerCacheService
local key = KEYS[1]
local seckillGoods = {}
local retailerId = ARGV[1]
local goodsId = ARGV[2]
local seckillGoodsKeys = redis.call('HVALS', key .. retailerId .. goodsId)
for _, value in ipairs(seckillGoodsKeys) do
    seckillGoods[value] = redis.call('HGET', key .. retailerId .. goodsId, value)
end

return cjson.encode(seckillGoods)


-- batchRollBackStorage GoodsRetailerCacheService
local key = KEYS[1]
local orderVO
local orderVOList = {}
local goodsId
local retailerId
for _, value in ipairs(ARGV) do
    orderVO = cjson.decode(value)
    goodsId = orderVO['goodsId']
    retailerId = orderVO['retailerId']
    if next(redis.call('HKEYS', key .. retailerId .. goodsId)) then
        orderVO['status'] = '库存回滚失败'
        table.insert(orderVOList, orderVO)
    else
        redis.call('HINCRBY', key .. retailerId .. goodsId, 'storage', orderVO['count'])
        orderVO['status'] = '库存回滚成功'
    end
end

if not next(orderVOList) then
    return nil
else
    return cjson.encode(orderVOList)
end


-- decreaseStorage GoodsRetailerCacheService
local key = KEYS[1]
local retailerId = ARGV[2]
local goodsId = ARGV[2]
local count = ARGV[3]
if tonumber(redis.call('HEGT', key .. retailerId .. goodsId, 'purchaseLimit')) < count then
    return false
end
if tonumber(redis.call('HINCRBY', key .. retailerId .. goodsId, 'storage', -count)) < 0 then
    redis.call('HINCRBY', key .. goodsId, 'storage', count)
    return false
else
    return true
end


-- batchSelectLogGoodsScript LogSeckillGoodsCacheService
--List<OrderVO> check(List<OrderVO> orderVOList)
--private String orderId;
--private Long goodsId;
--private Long userId;
--private Long retailerId;
--private BigDecimal goodsPrice;
--private Integer count;
--private BigDecimal orderPrice;
--private Date purchaseTime;
--private Boolean paid = false;
--private String status;
local key = KEYS[1]
local orderVO
local orderVOList = {}
local goodsId
for _, value in ipairs(ARGV) do
    orderVO = cjson.decode(value)
    key = '"' .. string.gsub(key, '"', '') .. goodsId .. '"'
    if tonumber(redis.call('LREM', key, 0, orderVO['orderId'] .. '-' .. 'CANCEL')) > 0 then
        redis.call('LPUSH', key, 0, orderVO['orderId'] .. '-' .. 'CANCEL')
        table.insert(orderVOList, orderVO)
    end
end

if not next(orderVOList) then
    return nil
else
    return cjson.encode(orderVOList)
end


-- canalSyncLogGoodsScript LogSeckillGoodsCacheService
--private Long id;
--private String orderId;
--private Long goodsId;
--private Long retailerId;
--private BigDecimal price;
--private BigDecimal seckillPrice;
--private Integer storage;
--private Integer purchaseLimit;
--private Date seckillStartTime;
--private Date seckillEndTime;
--private String operation;
local key = KEYS[1]
local redisCommand
local logSeckillGoods
local goodsId
local oldLogSeckillGoods
for _, value in ipairs(ARGV) do
    redisCommand = cjson.decode(value)
    logSeckillGoods = redisCommand['value']
    goodsId = logSeckillGoods['goodsId']
    key = '"' .. string.gsub(key, '"', '') .. goodsId .. '"'
    if command == 'INSERT' then
        redis.call('LPUSH', key, logSeckillGoods['orderId'] .. '-' .. logSeckillGoods['operation'])
    elseif command == 'UPDATE' then
        oldLogSeckillGoods = redisCommand['oldValue']
        if oldLogSeckillGoods['operation'] ~= nil then
            redis.call('LPUSH', key, logSeckillGoods['orderId'] .. '-' .. logSeckillGoods['operation'])
            redis.call('LREM', key, 0, logSeckillGoods['orderId'] .. '-' .. oldLogSeckillGoods['operation'])
        end
    else
        redis.call('LREM', key, 0, logSeckillGoods['orderId'] .. '-' .. logSeckillGoods['operation'])
    end
end


-- decreaseScript PurchasedUserCacheService
local key = KEYS[1]
local orderVOList = {}
for _, value in ipairs(ARGV) do
    local orderVO = cjson.decode(value)
    key = '"' .. string.gsub(key, '"', '') .. orderVO['userId'] .. '"'
    local count = tonumber(redis.call('DECR', key))
    if count < 0 then
        redis.call('SET', key, 0)
        table.insert(orderVOList, orderVO)
    end
end
if not next(orderVOList) then
    return nil
else
    return cjson.encode(orderVOList)
end


--test
local value = ARGV[1]
local redisCommand = cjson.decode(value)
local orderVO = redisCommand['value']
orderVO['@type'] = 'com.waibao.seckill.entity.SeckillGoods'
return cjson.encode(orderVO)

--{"command":"SET","timestamp":1646396955989,"value":{"goodsId":2,"id":2,"purchaseLimit":1,"retailerId":22,"seckillEndTime":1646396599000,"seckillStartTime":1646396597000,"storage":13100}}