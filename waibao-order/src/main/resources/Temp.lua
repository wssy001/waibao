---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by alexpetertyler.
--- DateTime: 2022/2/28 14:55
---

-- batchInsertScript OrderUserCacheService
local key = KEYS[1]
local orderUserList = {}
for index, value in ipairs(ARGV) do
    local orderUser = cjson.decode(value)
    local count = tonumber(redis.call('SETNX', key .. orderUser["userId"], orderUser["orderId"]))
    if count == 0 then
        table.insert(orderUserList, orderUser)
    end
end
if table.maxn(orderUserList) == 0 then
    return nil
else
    return cjson.encode(orderUserList)
end

-- batchDeleteScript OrderUserCacheService
local key = KEYS[1]
local orderUserList = {}
for index, value in ipairs(ARGV) do
    local orderUser = cjson.decode(value)
    local count = tonumber(redis.call('SREM', key .. orderUser["userId"], orderUser["orderId"]))
    if count == 0 then
        table.insert(orderUserList, orderUser)
    end
end
if table.maxn(orderUserList) == 0 then
    return nil
else
    return cjson.encode(orderUserList)
end

-- canalSyncScript OrderUserCacheService
local key = KEYS[1]
for index, value in ipairs(ARGV) do
    local redisCommand = cjson.decode(value)
    local orderUser = redisCommand['value']
    key = '"' .. string.gsub(key, '"', '') .. orderUser['userId'] .. '"'
    if redisCommand['command'] == 'SET' then
        orderUser['@type'] = 'com.waibao.order.entity.OrderUser'
        redis.call('SET', key, cjson.encode(orderUser))
    else
        redis.call('DEL', key)
    end
end

-- batchInsertScript OrderRetailerCacheService
local key = KEYS[1]
local orderRetailerList = {}
for index, value in ipairs(ARGV) do
    local orderRetailer = cjson.decode(value)
    local count = tonumber(redis.call('SETNX', key .. orderRetailer["retailerId"], orderRetailer["orderId"]))
    if count == 0 then
        table.insert(orderRetailerList, orderRetailer)
    end
end
if table.maxn(orderRetailerList) == 0 then
    return nil
else
    return cjson.encode(orderRetailerList)
end

-- batchDeleteScript OrderRetailerCacheService
local key = KEYS[1]
local orderRetailerList = {}
for index, value in ipairs(ARGV) do
    local orderRetailer = cjson.decode(value)
    local count = tonumber(redis.call('SREM', key .. orderRetailer["retailerId"], orderRetailer["orderId"]))
    if count == 0 then
        table.insert(orderRetailerList, orderRetailer)
    end
end
if table.maxn(orderRetailerList) == 0 then
    return nil
else
    return cjson.encode(orderRetailerList)
end

-- canalSyncScript OrderRetailerCacheService
local key = KEYS[1]
for index, value in ipairs(ARGV) do
    local redisCommand = cjson.decode(value)
    local orderRetailer = redisCommand['value']
    key = '"' .. string.gsub(key, '"', '') .. orderRetailer['retailerId'] .. '"'
    if redisCommand['command'] == 'SET' then
        orderRetailer['@type'] = 'com.waibao.order.entity.OrderRetailer'
        redis.call('SET', key, cjson.encode(orderRetailer))
    else
        redis.call('DEL', key)
    end
end

-- batchInsertScript OrderGoodsCacheService
local key = KEYS[1]
local orderGoodsList = {}
for index, value in ipairs(ARGV) do
    local orderGoods = cjson.decode(value)
    local count = tonumber(redis.call('SETNX', key .. orderGoods["orderId"], value))
    if count == 0 then
        table.insert(orderGoodsList, orderGoods)
    end
end
if table.maxn(orderGoodsList) == 0 then
    return nil
else
    return cjson.encode(orderGoodsList)
end

-- batchUpdateScript OrderGoodsCacheService
local key = KEYS[1]
local orderGoodsList = {}
for index, value in ipairs(ARGV) do
    local orderGoods = cjson.decode(value)
    local count = tonumber(redis.call('DEL', key .. orderGoods["orderId"]))
    if count == 0 then
        table.insert(orderGoodsList, orderGoods)
    else
        redis.call('SET', key .. orderGoods["orderId"], value)
    end
end
if table.maxn(orderGoodsList) == 0 then
    return nil
else
    return cjson.encode(orderGoodsList)
end

-- batchDeleteScript OrderGoodsCacheService
local key = KEYS[1]
local orderGoodsList = {}
for index, value in ipairs(ARGV) do
    local orderGoods = cjson.decode(value)
    local count = tonumber(redis.call('DEL', key .. orderGoods["orderId"]))
    if count == 0 then
        table.insert(orderGoodsList, orderGoods)
    end
end
if table.maxn(orderGoodsList) == 0 then
    return nil
else
    return cjson.encode(orderGoodsList)
end

-- canalSyncScript OrderGoodsCacheService
local key = KEYS[1]
for index, value in ipairs(ARGV) do
    local redisCommand = cjson.decode(value)
    local orderVO = redisCommand['value']
    key = '"' .. string.gsub(key, '"', '') .. orderVO['orderId'] .. '"'
    if redisCommand['command'] == 'SET' then
        orderVO['@type'] = 'com.waibao.util.vo.order.OrderVO'
        redis.call('SET', key, cjson.encode(orderVO))
    else
        redis.call('DEL', key)
    end
end

-- checkOperation LogOrderRetailerCacheService
local key = KEYS[1]
local count = tonumber(redis.call('LREM', key, 0, ARGV[1] .. '-' .. ARGV[2]))
if count > 0 then
    redis.call('LPUSH', key, ARGV[1] .. '-' .. ARGV[2])
    return true
else
    return false
end

-- batchInsertScript LogOrderRetailerCacheService
local key = KEYS[1]
for index, value in ipairs(ARGV) do
    local logOrderRetailer = cjson.decode(value)
    key = '"' .. string.gsub(key, '"', '') .. logOrderRetailer['retailerId'] .. '"'
    redis.call('LPUSH', key, logOrderRetailer['orderId'] .. '-' .. logOrderRetailer['operation'])
end

-- canalSyncScript LogOrderRetailerCacheService
local key = KEYS[1]
for index, value in ipairs(ARGV) do
    local redisCommand = cjson.decode(value)
    local logOrderRetailer = redisCommand['value']
    key = '"' .. string.gsub(key, '"', '') .. logOrderRetailer['retailerId'] .. '"'
    local command = redisCommand['command']
    if command == 'INSERT' then
        redis.call('LPUSH', key, logOrderRetailer['orderId'] .. '-' .. logOrderRetailer['operation'])
    elseif command == 'UPDATE' then
        local oldLogOrderRetailer = redisCommand['oldValue']
        if oldLogOrderRetailer['operation'] ~= nil then
            redis.call('LPUSH', key, logOrderRetailer['orderId'] .. '-' .. logOrderRetailer['operation'])
            redis.call('LREM', key, 0, logOrderRetailer['orderId'] .. '-' .. oldLogOrderRetailer['operation'])
        end
    else
        redis.call('LREM', key, 0, logOrderRetailer['orderId'] .. '-' .. logOrderRetailer['operation'])
    end
end

-- checkOperation LogOrderUserCacheService
local key = KEYS[1]
local count = tonumber(redis.call('LREM', key, 0, ARGV[1] .. '-' .. ARGV[2]))
return count ~= true

-- batchInsertScript LogOrderUserCacheService
local key = KEYS[1]
for index, value in ipairs(ARGV) do
    local logOrderUser = cjson.decode(value)
    key = '"' .. string.gsub(key, '"', '') .. logOrderUser['userId'] .. '"'
    redis.call('LPUSH', key, logOrderUser['orderId'] .. '-' .. logOrderUser['operation'])
end

-- canalSyncScript LogOrderUserCacheService
local key = KEYS[1]
for index, value in ipairs(ARGV) do
    local redisCommand = cjson.decode(value)
    local logOrderUser = redisCommand['value']
    key = '"' .. string.gsub(key, '"', '') .. logOrderUser['userId'] .. '"'
    local command = redisCommand['command']
    if command == 'INSERT' then
        redis.call('LPUSH', key, logOrderUser['orderId'] .. '-' .. logOrderUser['operation'])
    elseif command == 'UPDATE' then
        local oldLogOrderUser = redisCommand['oldValue']
        if oldLogOrderUser['operation'] ~= nil then
            redis.call('LPUSH', key, logOrderUser['orderId'] .. '-' .. logOrderUser['operation'])
            redis.call('LREM', key, 0, logOrderUser['orderId'] .. '-' .. oldLogOrderUser['operation'])
        end
    else
        redis.call('LREM', key, 0, logOrderUser['orderId'] .. '-' .. logOrderUser['operation'])
    end
end